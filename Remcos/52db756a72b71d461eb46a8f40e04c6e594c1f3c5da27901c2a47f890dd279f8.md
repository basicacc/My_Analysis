At the time of writing it is around a day that malicious script appeared in wild. To practice and improve myself I chose this malware.

For now in virustotal, it can be seen that malware is only detected by 9 AVs and the server for downloading second payload (*png* file) is still available to be downloaded. 

Starting with analysis, The file's size is really big but only reason for it was repeat of same 10 lines. 
![1|500](https://github.com/basicacc/basicacc.github.io/blob/main/My_analysis/Malware_4/1.png?raw=true)

Using ASCII table we can replace all occurrences of these variables with their Char values.

At first it looked like it is only repeating same 10 line for increasing file size (to look legit), but one more reason was probably trying to hide obfuscated code. (Maybe not but only good explanation is this)
![1|1000](https://github.com/basicacc/basicacc.github.io/blob/main/My_analysis/Malware_4/2.png?raw=true)

At first it might not make sense but you can obviously see same pattern repeat in obfuscated code:
`"‚è≥‡§≤·Éë‚£ø‡ºë‚Ç´·®ë‘øüñ≤·Ö´“å‚ä£·àí»™‚üö"`

and payload use `categorised(ByVal inputText)` function to deobfuscate it. (By removing repeating line)
![1|800](https://github.com/basicacc/basicacc.github.io/blob/main/My_analysis/Malware_4/3.png?raw=true)

In this situation manually writing deobfuscater  would be possible to but, it is waste of time. I just changed `dozens = categorised(dozens)` with `WScript.Echo categorised(dozens)` (Don't forget to only copy necessary parts in new file to avoid running something dangerous). I ran the code using **cscript.exe** to see output in my **cmd**.

![1|800](https://github.com/basicacc/basicacc.github.io/blob/main/My_analysis/Malware_4/4.png?raw=true)

Now to deobfuscate, we need to replace '#' with 'A' and convert base64 to string. Once again instead of using cyberchef I just run powershell code with removing `Invoke-Expression` and beautify it a little bit. This is the code that downloads second file. (png)

![1|800](https://github.com/basicacc/basicacc.github.io/blob/main/My_analysis/Malware_4/5.png?raw=true)
A day later, the malicious file was deleted from server but I installed it before, so I can continue my analysis. I will also upload file to **malware bazaar** for anyone that needs it to analyse on his own.

This image file has Data starting with '<<BASE64_START>>' and ends with '<<BASE64_END>>' after decoded it is uploaded to memory but I modified code and used function:
```ps1
[System.IO.File]::WriteAllBytes("C:\dnlib_image.dll", $cleared)
```

to save it in a file and when we load this dll to dnspy-x86, it loads it as `Microsoft.Win32.TaskScheduler, Version=1.1.0.0` and dnlib inside, which is necessary part of us:
![1|800](https://raw.githubusercontent.com/basicacc/basicacc.github.io/refs/heads/main/My_analysis/Malware_4/6.png)

You can check out [Robson Felix's VMDetector](https://github.com/robsonfelix/VMDetector)to understand how it works. I modified qemu strings in my system so I have 0 "qemu" string in my system which helps me avoid detection. this script is really basic as it checks for only "qemu" (easy to stay undetected). 
Note: Even though this malware has function to check detect vms, it doesn't use it. (if you remember the arguments given when VAI is called, they are necessary part of this function)

In next line we can see the malicious code calling specific function that is interesting for us, **VAI**.

![1|1000](https://github.com/basicacc/basicacc.github.io/blob/main/My_analysis/Malware_4/7.png?raw=true)


some of the variable names are written in Spanish, which might be a tip for malware writer being Spanish. (Of course, it is not a guarantee) 

I have written custom code in C# to be able to manually debug this dll. 

The functions function didn't use: persistence, startuptask, startupreg (even though it could). (To make it clear these are not function names, these are variables)

Moving on, startup_onstart is actually used, let's understand what it does.
Before understanding the function, I retrivied Hashtable values that are used through dll and saved all of them to single file to make analysis easier.

This is the part we have to analyze now:
```csharp
if (flag12)
{
	bool flag13 = !File.Exists(Path.Combine(caminho, nomedoarquivo + \uE11C.\uE000(12567) + exten√ßao));
	bool flag14 = flag13;
	if (flag14)
	{
		Process.Start(new ProcessStartInfo
		{
			WindowStyle = ProcessWindowStyle.Hidden,
			FileName = \uE11C.\uE000(12607), // "cmd.exe"
			Arguments = string.Concat(new string[]
			{
				// "/C copy *."
				\uE11C.\uE000(12599),
				// "vbs"
				exten√ßao,
				// " \""
				\uE11C.\uE000(12770),
				//  1. @"C:\ProgramData" 2. "millipascals"
				Path.Combine(caminho, nomedoarquivo), 
				// "."
				\uE11C.\uE000(12567),
				// "vbs"
				exten√ßao,
				// "\""
				\uE11C.\uE000(12282)
			})
		}).WaitForExit();
	}
	Loader.ExecutarMetodoVAI(taskname, caminho, nomedoarquivo, exten√ßao);
}
```

Basically checks if file exists, if not, starts new process: 
`cmd.exe /C copy *.vbs "C:\ProgramData\millipascals.vbs" 
copies the vbs file to its new location.

**ExecutarMetodoVAI** is called with arguments: `"blinkered" @"C:\ProgramData"	"millipascals" "vbs"`

at first line, function searches for specific string in resources:
`string¬†text¬†=¬†Array.Find<string>(Assembly.GetExecutingAssembly().GetManifestResourceNames(),¬†new¬†Predicate<string>(Loader.<>c.<>9.\uE000));`

When using dnspy, it hides compiler generated types and modules by default which you need to enable.

The `(Loader.<>c.<>9.\uE000)` sets condition **true** if "string" ends with "UAC.dll"
and in next lines, first stream is loaded into an array and array was loaded to caller program (powershell):
```C#
byte[] array;
using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(text))
{
	using (MemoryStream memoryStream = new MemoryStream())
	{
		manifestResourceStream.CopyTo(memoryStream);
		array = memoryStream.ToArray();
	}
}
Assembly assembly = Assembly.Load(array);
```


and calls "Main" method in UAC.dll (type:UAC.Program).

![1|800](https://raw.githubusercontent.com/basicacc/basicacc.github.io/refs/heads/main/My_analysis/Malware_4/8.png)

Which I will use new custom script to run it and debug manually.